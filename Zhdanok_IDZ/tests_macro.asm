.include "fill_new_massive.asm"
.include "macrolib.asm"

.data
.align 2
	array_new: .space 40
	msg_ok: .asciz "\n\nМассивы равны, тест пройден\n"
	msg_fail: .asciz "Массивы не равны, тест не пройден\n"
	array_test: .asciz "Ожидаемый результат: \n"
	array_result: .asciz "\nИтоговый массив: \n"

#макро, рчищающий память массива
.macro clear(%addr, %count)
	#формальные параметры addr - указатель на память, которую надо очистить, count - длина области памяти
    	la   t0 %addr        
    	mv   t1 %count      
    	mv   t2 zero         
loop:
    	beq  t1 zero end
    	sw   t2 0(t0)
    	addi t0 t0 4
    	addi t1 t1 -1
    	j    loop
end:
	.end_macro
	
.macro equal_massive(%arr1, %arr2, %length, %res_len)
	#фактические параметры: arr1 - получившийся в результате работы функции массив, arr2 - предполагаемый результат, length - длина первого массива, res_len - второго
    	addi sp sp -16

    	la t0 %arr1         # указатель на первый массив
    	la t1 %arr2         # указатель на второй массив
    	mv t2 %length       # длина массивов
    	mv t4 %res_len
    	bne t2 t4 eq_not
    	li t3 0             # счётчик

eq_loop:
    	bge t3 t2 eq_equal # если дошли до конца — равны
    	lw t4 (t0) # элемент из первого
    	lw t5 (t1) # элемент из второго
    	bne t4 t5 eq_not # если не равны — выход
    	addi t0 t0 4
    	addi t1 t1 4
    	addi t3 t3 1
    	j eq_loop

eq_equal:
    	li a0 1  # равны
    	j eq_end

eq_not:
    	li a0 0             # не равны

eq_end:
    	addi sp sp 16
.end_macro

.macro run_test(%array, %res, %len1, %res_len)
	#формальные параметры: первый - исходный массив,  второй - ожилаемый результат, третий - длина исходного массива, четвёртый - длина ожидаемого результата
	addi sp sp -16
	la t0  %len1
	lw t1 (t0)
	
	sw t1 (sp) #загрузка длины исходного массива
	mv t5 t1
	
	la t0 %array
	sw t0 4(sp) #указатель на память старого массива
	
	la t0 array_new  #указатель на память нового массива
	sw t0 8(sp)
	
	sw t5 12(sp) #загружаем в стек длину нового массива
	
	#информация для работы подпрограммы лежит на стеке
	jal fill_new_massive
	
	lw t5 12(sp) #кладём в t5 длину нового массива
	addi sp sp 16
	
	la t0 %res_len
	lw t6 (t0)
	
	mv s0 t5
	
	equal_massive(array_new, %res, t5, t6) #проверка совпадения элементов массива; фактические параметры: первый - получившийся в результате работы функции массив, второй - предполагаемый результат, третий - длина первого массива, четвёртый - второго
    	beq a0 zero not_equal
    	
    	#вывод результатов
    	print_string(msg_ok) #печать строки, фактический параметр - сообщение о положительном результате
    	print_string (array_test) #печать строки, фактический параметр - сообщение о дальнейшем выводе ожидаемого результата
    	write_massive(t6, %res) #печать массива, фактические параметры: длина тестового массива и указатель на него
    	print_string (array_result)  #печать строки, фактический параметр - сообщение о дальнейшем выводе фактического результата
    	write_massive(s0, array_new) #печать массива, фактические параметры: длина полученного массива и указатель на него
    	j done

not_equal:
    	print_string(msg_fail) #печать строки, фактический параметр - сообщение о негативном результате
    	print_string (array_test)#печать строки, фактический параметр - сообщение о дальнейшем выводе ожидаемого результата
    	write_massive(t6, %res)#печать массива, фактические параметры: длина тестового массива и указатель на него
    	print_string (array_result) #печать строки, фактический параметр - сообщение о дальнейшем выводе фактического результата
    	write_massive(s0, array_new) #печать массива, фактические параметры: длина полученного массива и указатель на него

done: 
	#очистка иогового массива перед новым запуском
	clear(array_new, s0) #фактические параметры:
.end_macro
